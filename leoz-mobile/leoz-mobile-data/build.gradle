import groovy.io.FileType
import org.flywaydb.core.Flyway
import org.jboss.forge.roaster.model.source.JavaInterfaceSource
import org.jooq.util.DefaultGeneratorStrategy
import org.jooq.util.Definition
import org.jooq.util.GenerationTool
import org.jooq.util.GeneratorStrategy
import org.jooq.util.sqlite.SQLiteDatabase
import org.jooq.util.jaxb.*
import org.jboss.forge.roaster.Roaster
import org.jboss.forge.roaster.model.source.*

buildscript {
    ext {
        v_xerial_sqlite = '3.15.1'
    }

    dependencies {
        classpath(
                "org.jetbrains.kotlin:kotlin-gradle-plugin:$v_kotlin",
                "org.xerial:sqlite-jdbc:$v_xerial_sqlite",
                "org.flywaydb:flyway-gradle-plugin:$v_flyway",
                // JOOQ
                "org.jooq:jooq:$v_jooq",
                "org.jooq:jooq-meta:$v_jooq",
                "org.jooq:jooq-codegen:$v_jooq",
                // Roaster
                "org.jboss.forge.roaster:roaster-api:$v_roaster",
                "org.jboss.forge.roaster:roaster-jdt:$v_roaster",
                "org.apache.commons:commons-lang3:$v_commons_lang",

                "org.eclipse.persistence:eclipselink:$v_eclipselink"
        )
    }
}

apply plugin: 'java'
apply plugin: 'kotlin'
apply plugin: 'org.flywaydb.flyway'
apply plugin: 'idea'

sourceCompatibility = 1.7
targetCompatibility = 1.7

//region Constants

// Database related parameters
def DB_FILENAME = 'leoz-mobile.db'
def DB_RESOURCES_DIR = new File(project.projectDir, 'src/main/resources/db')
def DB_DIR = new File(project.buildDir, 'db')
def DB_FILE = new File(DB_DIR, DB_FILENAME)

// Flyway parameters
def FLYWAY_MIGRATION_DIR = new File(DB_RESOURCES_DIR, 'migration')
def FLYWAY_TASK_GROUP = 'flyway'

// JDBC parameters
def JDBC_DRIVER = 'org.sqlite.JDBC'
def JDBC_URL = "jdbc:sqlite:${DB_FILE}"

/** Base directory for generated classes */
def GENERATED_DIR = file("${project.projectDir}/src/generated")
/** The base path for generated classes by jooq */
def JOOQ_GENERATED_DIR = new File(GENERATED_DIR, 'jooq')
/** Folder where kapt generates source files */
def KAPT_GENERATED_DIR = new File(project.buildDir, 'generated/source/kapt/main')
/** A destination folder where we sync kapt generated classes to, referring to kaptSync task/workaround see below */
def KAPT_DST_GENERATED_DIR = new File(GENERATED_DIR, 'kapt')

class Constants {
    /** Package name for jooq generated classes */
    static def JOOQ_PACKAGE_NAME = 'org.deku.leoz.android.data.jooq'
    /** Package name for jpa classes */
    static def JPA_PACKAGE_NAME = 'org.deku.leoz.android.data.jpa'
}

def JOOQ_PACKAGE_NAME = Constants.JOOQ_PACKAGE_NAME
def JPA_PACKAGE_NAME = Constants.JPA_PACKAGE_NAME
//endregion

kapt {
    generateStubs = true
}

idea {
    module {
        // Add KAPT generated sources to intellij
        sourceDirs += KAPT_DST_GENERATED_DIR
    }
}

// TODO: stupid workaround for making AndroidStudio see kapt generated classes. Unlike IJ, AndroidStudio seems to ignore .java files in build dir even when they're explicltly added to `sourceDirs` via idea plugin
task kaptSync(type: Sync) {
    from KAPT_GENERATED_DIR
    into KAPT_DST_GENERATED_DIR
}
tasks.classes {
    dependsOn tasks.kaptSync
}

configurations {
    /** Configuration for loading (jdbc) driver within buildscript */
    driver
}

dependencies {
    compile(
            fileTree(dir: 'libs', include: ['*.jar']),

            "org.jetbrains.kotlin:kotlin-stdlib:$v_kotlin",

            // Kodein
            "com.github.salomonbrys.kodein:kodein-android:$v_kodein",
            "com.github.salomonbrys.kodein:kodein-conf:$v_kodein",

            // javax.persistence
            "org.eclipse.persistence:javax.persistence:$v_javax_persistence",

            // rx
            "io.reactivex:rxjava:$v_rxjava",
            "io.reactivex:rxkotlin:$v_rxkotlin",
            "com.github.davidmoten:rxjava-extras:0.8.0.5",

            // Requery
            "io.requery:requery:$v_requery",
    )

    compileOnly(
            // Roaster
            "org.jboss.forge.roaster:roaster-api:$v_roaster",
            "org.jboss.forge.roaster:roaster-jdt:$v_roaster",
            "org.apache.commons:commons-lang3:$v_commons_lang",
            "org.xerial:sqlite-jdbc:$v_xerial_sqlite",
    )

    driver(
            "org.xerial:sqlite-jdbc:$v_xerial_sqlite",
    )

    kapt(
            "io.requery:requery-processor:$v_requery"
    )

    testCompile(
            "junit:junit:$v_junit",
            "org.xerial:sqlite-jdbc:$v_xerial_sqlite",
    )
}

sourceSets {
    main {
        java {
            srcDirs += JOOQ_GENERATED_DIR
        }
    }

    test {
        java {
            srcDirs += KAPT_GENERATED_DIR
        }
    }
}

clean {
    doLast {
        GENERATED_DIR.deleteDir()
    }
}

flyway {
    driver = JDBC_DRIVER
    url = JDBC_URL
    locations = ["filesystem:${FLYWAY_MIGRATION_DIR}"]
}

// TODO: masc20161210. workaround for flyway bug https://github.com/flyway/flyway/issues/1180
// Replacing affected flyway tasks with alternative implementation that circumvents locking issue

tasks.remove(tasks.flywayMigrate)
task flywayMigrate(group: FLYWAY_TASK_GROUP) {
    inputs.dir FLYWAY_MIGRATION_DIR
    outputs.files DB_FILE
    doLast {
        DB_DIR.mkdirs()
        Flyway flyway = new Flyway();
        flyway.setLocations("filesystem:${FLYWAY_MIGRATION_DIR}");
        flyway.setDataSource("jdbc:sqlite:${DB_FILE}", "", "");
        flyway.migrate()
    }
}

tasks.remove(tasks.flywayClean)
task flywayClean(group: FLYWAY_TASK_GROUP) {
    doLast {
        DB_FILE.delete()
    }
}

tasks.clean.dependsOn(flywayClean)

//region JOOQ
/**
 * JOOQ generator strategy
 */
public class CustomJooqGeneratorStrategy extends DefaultGeneratorStrategy {
    @Override
    String getJavaPackageName(Definition definition, GeneratorStrategy.Mode mode) {
        def packageName = super.getJavaPackageName(definition, mode)
        // Mangle package name for jpa pojos
        if (mode == GeneratorStrategy.Mode.POJO) {
            packageName = Constants.JPA_PACKAGE_NAME
        } else if (mode == GeneratorStrategy.Mode.INTERFACE) {
            packageName = Constants.JPA_PACKAGE_NAME
        }

        return packageName
    }
}

/**
 * JOOQ generator configuration
 */
def jooqConfiguration = new Configuration()
        .withJdbc(
        new Jdbc()
                .withDriver(JDBC_DRIVER)
                .withUrl(JDBC_URL))
        .withGenerator(
        new Generator()
                .withGenerate(
                new Generate()
                        .withRecords(false)
                        .withDaos(false)
//                        .withPojos(true)
                        .withInterfaces(true)
//                        .withPojosEqualsAndHashCode(true)
                        .withJpaAnnotations(true)
                        .withFluentSetters(false))
                .withStrategy(new Strategy()
                .withName(CustomJooqGeneratorStrategy.class.canonicalName))
                .withDatabase(
                new Database()
                        .withName(SQLiteDatabase.class.canonicalName)
                        .withInputSchema('')
        )
                .withTarget(
                new Target()
                        .withPackageName(JOOQ_PACKAGE_NAME)
                        .withDirectory(JOOQ_GENERATED_DIR.toString())))

/**
 * Task generating JOOQ and JPA classes.
 * TODO: jooq plugin doesn't work correctly with customized generator strategy (class loading issue)
 */
task jooqGenerate(group: 'jooq') {
    dependsOn tasks.flywayMigrate
    mustRunAfter tasks.flywayMigrate

    inputs.dir FLYWAY_MIGRATION_DIR
    outputs.dir JOOQ_GENERATED_DIR

    doFirst {
        JOOQ_GENERATED_DIR.deleteDir()
    }

    doLast {
        GenerationTool.generate(jooqConfiguration)

        // Post process generated java classes
        jpaPostProcess(JOOQ_GENERATED_DIR)

        // Remove JOOQ classes (didn't find a way to disable this via `jooqConfiguration`
        new File(JOOQ_GENERATED_DIR, JOOQ_PACKAGE_NAME.replace('.', '/')).deleteDir()
    }
}
// Dependencies
tasks.compileJava {
    dependsOn tasks.jooqGenerate
    mustRunAfter tasks.jooqGenerate
}
tasks.compileKotlin {
    dependsOn tasks.jooqGenerate
    mustRunAfter tasks.jooqGenerate
}
//endregion

//region Support methods
/**
 * Performs post-processing on jpa-generated entity classes.
 * @param sourceDir Generated sources dir (to process)
 */
static def jpaPostProcess(File sourceDir) {
    // Iterate source files
    sourceDir.eachFileRecurse(FileType.FILES, {
        if (!it.name.endsWith(".java"))
            return

        def jtype = Roaster.parse(it)

        // Look for JPA annotations
        def tableAnnotation = jtype.annotations.find {
            it.qualifiedName == javax.persistence.Table.canonicalName
        }

        if (tableAnnotation == null)
            // Skip
            return

        if (jtype instanceof JavaInterfaceSource) {
            // Post-processing for interfaces.
            def jsource = (JavaInterfaceSource) jtype

            // Collect all methods belonging to properties
            def propertyMethods = jsource.properties.collect { it.mutator } + jsource.properties.collect { it.accessor }

            // Remove interface methods which don't belong to properties
            jsource.methods
                    .findAll { !propertyMethods.contains(it) }
                    .each {
                jsource.removeMethod(it)
            }

            jsource.methods.each {
                def columnAnnotation = it.annotations.find { it.qualifiedName == javax.persistence.Column.canonicalName }

                if (columnAnnotation != null) {
                    def c = (AnnotationSource) columnAnnotation

                    def name = 'name'
                    def val = c.getStringValue(name)

                    // Field names to escape
                    if (val == 'timestamp') {
                        c.setStringValue(name, "'${val}'")
                    }
                }
            }
        } else if (type instanceof JavaClassSource) {
            // Post-processing for java classes
            def jsource = (JavaClassSource) jtype

            // Amend member access rights for properties
            jsource.fields.each {
                def fieldSource = (FieldSource) it
                fieldSource.setPackagePrivate()
            }

            jsource.properties.each {
                def propertySource = (PropertySource) it
                propertySource.accessor.setPackagePrivate()
                propertySource.mutator.setPackagePrivate()
            }
        }

        // Rewrite class
        it.write(jtype.toString())
    })
}
//endregion
