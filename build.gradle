import sx.platform.PlatformId

import java.nio.file.Paths

version = '0.1'

apply from: 'versions.gradle'

buildscript {
    ext {
        // Leoz release path, relative to root project
        g_platform_identifier = PlatformId.current().toString()

        g_release_path = Paths.get(project.rootDir.toURI())
                .resolve("release")
                .toFile()

        g_bin_path = new File(project.rootDir, 'bin')

        g_osx_icon = Paths.get(project.rootDir.toURI())
                .resolve('images')
                .resolve('DEKU.icon.icns')
                .toFile()

        g_windows_icon = Paths.get(project.rootDir.toURI())
                .resolve('images')
                .resolve('DEKU.icon.ico')
                .toFile()
    }

    repositories {
        mavenCentral()
        jcenter()
    }

    dependencies {
        classpath "ca.cutterslade.gradle:gradle-dependency-analyze:1.1.0"
        classpath 'com.github.ben-manes:gradle-versions-plugin:0.13.0'
    }
}

// TODO. sometimes packager creates corrupt archives, presumably since intellij's MAKE confuses gradle's uptodate detection, thus forcing rerun of all tasks when running a release task
//if (gradle.startParameter.taskNames.contains("releaseUpdate") ||
//        gradle.startParameter.taskNames.contains("releasePush") ||
//        gradle.startParameter.taskNames.contains("releaseSfx")) {
//    println "Detected packager deployment task, enforcing re-run of all tasks"
//    gradle.startParameter.rerunTasks = true
//}

// Start parameters
// TODO. not available since gradle-2.14. may have to find another way
//gradle.startParameter.showStacktrace = ShowStacktrace.ALWAYS

// Common configuration for subprojects
subprojects {

    // Common subproject buildscript configuration
    buildscript {
        repositories {
            mavenCentral()
            jcenter()
        }
    }

    // Common plugins
    apply plugin: 'base'
    apply plugin: 'java'
    // For generating dependency reports
    apply plugin: 'project-report'
    // Analzye tasks (analyze* for showing unused dependencies eg.)
    apply plugin: 'ca.cutterslade.analyze'
    // Plugin for showing dependency updates
    apply plugin: 'com.github.ben-manes.versions'

    // Global repositories
    repositories {
        mavenCentral()
        jcenter()
    }

    // Global jar configuration
    tasks.jar.doFirst {
        jar {
            manifest {
                if (project.hasProperty('mainClassName')) {
                    attributes(
                        'Main-Class': project.mainClassName
                    )
                }

                attributes (
                        'Implementation-Name': project.name,
                        'Implementation-Version': project.version,
                        'Class-Path': configurations.compile.collect { it.getName() }.join(' ')
                )
            }

            entryCompression ZipEntryCompression.STORED
        }
    }

    // Global dependency resolution
    configurations.all {
        resolutionStrategy {
            // masc20161012. disabled conflict resolution for now, as it prevents the `dependencyUpdates` task
            // from listing the dependencies that have been forced.
            // @see https://github.com/ben-manes/gradle-versions-plugin/issues/103

//            // Fail eagerly on version conflict (includes transitive dependencies)
//            // e.g. multiple different versions of the same dependency (group and name are equal)
//            failOnVersionConflict()
//
//            // Force overrides for newer versions of (transitive) dependencies for all projects consistently
//            // Version overrides
//            resolutionStrategy.eachDependency { DependencyResolveDetails details ->
//                if (details.requested.group.startsWith('com.fasterxml.jackson')) {
//                    details.useVersion v_jackson
//                }
//                else if (details.requested.group == 'org.slf4j') {
//                    details.useVersion v_slf4j
//                }
//                else if (details.requested.group == 'org.springframework') {
//                    details.useVersion v_spring
//                }
//                else if (details.requested.group == 'org.springframework.boot') {
//                    details.useVersion v_springboot
//                }
//            }
//
//            force "commons-beanutils:commons-beanutils:1.9.3"
//            force "commons-collections:commons-collections:3.2.2"
//            force "commons-codec:commons-codec:1.10"
//            force "commons-io:commons-io:$v_commons_io"
//            force "commons-logging:commons-logging:$v_commons_logging"
//            force "com.fasterxml:classmate:1.3.0"
//            force "com.google.code.findbugs:jsr305:3.0.0"
//            force "com.google.guava:guava:$v_guava"
//            force "com.thoughtworks.xstream:xstream:$v_xstream"
//            force "com.vaadin:vaadin-server:$v_vaadin"
//            force "io.reactivex:rxjava:$v_rxjava"
//            force "javax.validation:validation-api:1.1.0.Final"
//            force "net.java.dev.jna:jna:$v_jna"
//            force "org.apache.commons:commons-lang3:$v_commons_lang"
//            force "org.apache.httpcomponents:httpclient:4.5.2"
//            force "org.fusesource.hawtdispatch:hawtdispatch-transport:1.22"
//            force "org.fusesource.hawtbuf:hawtbuf:1.11"
//            force "org.hamcrest:hamcrest-core:1.3"
//            force "org.hibernate.common:hibernate-commons-annotations:5.0.1.Final"
//            force "org.javassist:javassist:$v_javassist"
//            force "org.jboss.logging:jboss-logging:3.2.1.Final"
//            force "org.jetbrains.kotlin:kotlin-stdlib:$v_kotlin"
//            force "org.jolokia:jolokia-core:1.3.4"
//            force "org.objenesis:objenesis:2.4"
//            force "org.ow2.asm:asm:5.0.4"
//            force "org.reflections:reflections:0.9.10"
//            force "org.xerial.snappy:snappy-java:$v_snappy"
//            force "org.yaml:snakeyaml:$v_snakeyaml"
        }
    }

    ext {
        globalPlatformDir = new File(project.rootDir, 'platform')
        sxRsyncPlatformDir = new File(project(':libs:sx-rsync').projectDir, 'platform')

        projectBuildSupplementalsDir = new File(project.buildDir, 'supplementals')
        projectBuildPlatformDir = new File(projectBuildSupplementalsDir, 'platform')
        projectBuildCurrentPlatformDir = new File(projectBuildPlatformDir, g_platform_identifier)
        platformDirRelative = new File('platform')

        projectPlatformDir = new File(project.projectDir, 'platform')
    }

    /**
     * Task copying platform specific files from sx-common to project dir
     */
    task copySxPlatformDirToProject(type: Copy) {
        from sxRsyncPlatformDir
        into projectPlatformDir
        // Rename generic name to leoz specific process name, as it's easier to handle,
        // when eg. looking at process names while leoz is running
        rename 'sx-rsync(.*)', 'leoz-rsync$1'
    }

    /**
     * Task copying platform specific files from sx-common to project build dir
     */
    task copySxPlatformDirToBuild(type: Copy) {
        from sxRsyncPlatformDir
        into projectBuildPlatformDir
        // Rename generic name to leoz specific process name, as it's easier to handle,
        // when eg. looking at process names while leoz is running
        rename 'sx-rsync(.*)', 'leoz-rsync$1'
    }
    tasks.copySxPlatformDirToBuild.dependsOn(tasks.copySxPlatformDirToProject)

    /**
     * Task copying architecture specific global files to project dri
     */
    task copyGlobalPlatformDirToProject(type: Copy) {
        from globalPlatformDir
        into projectPlatformDir
    }

    /**
     * Task copying architecture specific global files to project build dir
     */
    task copyGlobalPlatformDirToBuild(type: Copy) {
        from globalPlatformDir
        into projectBuildPlatformDir
    }
    tasks.copyGlobalPlatformDirToBuild.dependsOn(tasks.copyGlobalPlatformDirToProject)
}

// Data(base) sources in intellij contain hashes which are updated every time the IDE updates
// To avoid having a vcs change to reset every time, this configuration was moved to a separate file
// which is copied on each gradle run. Implies that _when_ datasources are updated (rare) the
// config file below needs to be updated manually.
//task copyIntellijDataSources(type: Copy) {
//    def ideaWorkspaceDir = '.idea'
//    def dataSourcesPresetFile = 'dataSources.preset.xml'
//    def dataSourcesFile = 'dataSources.xml'
//
//    if (!new File(ideaWorkspaceDir, dataSourcesFile).exists())
//        copy {
//            from(ideaWorkspaceDir)
//            into(ideaWorkspaceDir)
//            include dataSourcesPresetFile
//            rename dataSourcesPresetFile, dataSourcesFile
//        }
//}
//tasks.copyIntellijDataSources.execute()

