import com.jcraft.jsch.JSch
import com.jcraft.jsch.JSchException
import com.jcraft.jsch.Session
import com.jcraft.jsch.agentproxy.ConnectorFactory
import com.jcraft.jsch.agentproxy.RemoteIdentityRepository
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.transport.RefSpec
import org.eclipse.jgit.transport.JschConfigSessionFactory
import org.eclipse.jgit.transport.OpenSshConfig
import org.eclipse.jgit.transport.SshSessionFactory
import org.eclipse.jgit.util.FS
import java.time.Duration
import sx.ProcessExecutor
import sx.ProcessExecutor.ProcessRunException
import sx.packager.BundleRepository
import sx.platform.PlatformId
import sx.rsync.Rsync
import sx.ssh.SshHost
import sx.ssh.SshTunnelProvider
import sx.Stopwatch

import java.lang.management.ManagementFactory
import java.nio.file.Files
import java.nio.file.Paths

apply from: 'versions.gradle'
apply from: 'common.gradle'

def assertJvmVersion(String vmVersion) {
    def jvm = ManagementFactory.getRuntimeMXBean()
    println("JVM version [${jvm.specVersion}] [${jvm.vmVersion}]")
    if (!jvm.vmVersion.startsWith(vmVersion))
        throw new IllegalStateException("JVM/JDK version is [${jvm.vmVersion}], should start with [${vmVersion}]")
}

assertJvmVersion(v_jvm)

buildscript {
    ext {
        v_jgit = '4.8.0.201706111038-r'
        v_jsch = '0.0.9'
    }

    repositories {
        mavenCentral()
        jcenter()
        maven {
            url 'leoz-build/repo'
        }
    }

    dependencies {
        classpath "sx:sx-ssh:0.1"
        classpath "sx:sx-common:0.1"
        classpath "sx:sx-packager-gradle:0.1"
        classpath "sx:sx-serialization:0.1"

        classpath(
                "ca.cutterslade.gradle:gradle-dependency-analyze:1.1.0",
                'com.github.ben-manes:gradle-versions-plugin:0.15.0',
                'org.kordamp.gradle:stats-gradle-plugin:0.2.0'
        )
    }
}

ext {
    g_platform_identifier = PlatformId.current().toString()

    // Leoz release path, relative to root project
    g_release_path = Paths.get(project.rootDir.toURI())
            .resolve("release")
            .toFile()

    // Leoz icon for OSX packages
    g_osx_icon = Paths.get(project.rootDir.toURI())
            .resolve('images')
            .resolve('DEKU.icon.icns')
            .toFile()

    // Leoz icon for windows packages
    g_windows_icon = Paths.get(project.rootDir.toURI())
            .resolve('images')
            .resolve('DEKU.icon.ico')
            .toFile()

    // Distribution path for local dev VM
    g_vm_dist_path = project.rootDir.toPath()
            .resolve('vm')
            .resolve('dist')
            .toFile()
}

// Common configuration for all subprojects (including android)
subprojects {
    // Common subproject buildscript configuration
    buildscript {
        repositories {
            mavenCentral()
            jcenter()
        }
    }

    // Global repositories
    repositories {
        mavenCentral()
        jcenter()
    }

    // For generating dependency reports
    apply plugin: 'project-report'
    // Plugin for showing dependency updates
    apply plugin: 'com.github.ben-manes.versions'
    // Plugin for showing code statistics (Sourcefiles, LOC) `gradlew stats`
    apply plugin: 'org.kordamp.gradle.stats'

    // Set boot classpath for all subprojects (eliminates warning in conjunction with setting sourceCompatibility)
    tasks.withType(JavaCompile) {
        options.bootClasspath = ManagementFactory.getRuntimeMXBean().bootClassPath
    }

    ext {
        globalPlatformDir = new File(project.rootDir, 'platform')
        rsyncPlatformDir = new File(project(':sx-rsync').projectDir, 'platform')

        buildSupplementalsDir = new File(project.buildDir, 'supplementals')
        buildPlatformDir = new File(buildSupplementalsDir, 'platform')
        projectPlatformDir = new File(project.projectDir, 'platform')
    }

    plugins.withType(JavaPlugin).whenPluginAdded {
        //region Since IJ-2017.2, default output path is `out`. Unify so both build toolchains share the same output path
        // REMARK: possibly a better approach would be to synchronize gradle build output to IJ out directories
        project.apply plugin: 'idea'
        project.idea {
            module {
                outputDir = project.sourceSets.main.output.classesDirs[0]
            }
        }
        //endregion

        project.test {
            ignoreFailures true
        }

        // Global jar configuration
        project.jar {
            doFirst {
                jar {
                    manifest {
                        if (project.hasProperty('mainClassName')) {
                            attributes(
                                    'Main-Class': project.mainClassName
                            )
                        }

                        attributes(
                                'Implementation-Name': project.name,
                                'Implementation-Version': project.version,
                                'Class-Path': configurations.compile.collect { it.getName() }.join(' ')
                        )
                    }

                    entryCompression ZipEntryCompression.STORED
                }
            }
        }

        // Analzye tasks (analyze* for showing unused dependencies eg.)
        project.apply plugin: 'ca.cutterslade.analyze'

        // Remove dependency to check task, as analysis plugin is good for hinting at dependency, but there's also false positives
        check.dependsOn.remove('analyzeDependencies')
    }

    // Setup common sx-packager-gradle plugin properties for all subprojects
    plugins.withType(sx.packager.gradle.PackagerPlugin).whenPluginAdded {
        SshTunnelProvider mySshTunnelProvider = new SshTunnelProvider(
                new kotlin.ranges.IntRange(13300, 13350),
                new SshHost(
                        "",
                        13003,
                        "leoz",
                        "MhWLzHv0Z0E9hy8jAiBMRoO65qDBro2JH1csNlwGI3hXPY8P8NOY3NeRDHrApme8"))

        packager {
            sshTunnelProvider = mySshTunnelProvider
            bundleRepository = new BundleRepository(
                    new Rsync.URI("rsync://leoz@leoz.derkurier.de:13002/bundles"),
                    '2FBVQsfQqZOgpbSSipdZuatQCuaogyfYc9noFYRZO6gz3TwGRDLDiGXkRJ70yw5x',
                    mySshTunnelProvider)

            releaseBasePath = g_release_path
            osxIcon = g_osx_icon
            windowsIcon = g_windows_icon
            nativePlatformDir = new File(project(':sx-rsync').projectDir, 'platform')
            supplementalPlatformDirs(
                    (buildPlatformDir): new File('platform')
            )
        }
    }

    plugins.withType(DistributionPlugin).whenPluginAdded {
        project.gradle.projectsEvaluated {
            tasks.installDist {
                doLast {
                    def src = project.buildDir.toPath()
                            .resolve("install")
                            .resolve(project.name)

                    def dst = g_vm_dist_path
                            .toPath()
                            .resolve(project.name)

                    println("Moving [${src}] to [${dst}]")

                    if (Files.exists(dst)) dst.deleteDir()
                    g_vm_dist_path.mkdirs()
                    Files.move(src, dst)
                }
            }
        }
    }

    /**
     * Task copying platform specific files from sx-rsync to project dir
     */
    task copyRsyncPlatformDirToProject(type: Copy) {
        from rsyncPlatformDir
        into projectPlatformDir
        // Rename generic name to leoz specific process name, as it's easier to handle,
        // when eg. looking at process names while leoz is running
        rename 'sx-rsync(.*)', 'leoz-rsync$1'
    }

    /**
     * Task copying platform specific files from sx-rsync to project build dir
     */
    task copyRsyncPlatformDirToBuild(type: Copy) {
        from rsyncPlatformDir
        into buildPlatformDir
        // Rename generic name to leoz specific process name, as it's easier to handle,
        // when eg. looking at process names while leoz is running
        rename 'sx-rsync(.*)', 'leoz-rsync$1'
    }
    tasks.copyRsyncPlatformDirToBuild.dependsOn(tasks.copyRsyncPlatformDirToProject)

    /**
     * Task copying architecture specific global files to project dri
     */
    task copyGlobalPlatformDirToProject(type: Copy) {
        from globalPlatformDir
        into projectPlatformDir
    }

    /**
     * Task copying architecture specific global files to project build dir
     */
    task copyGlobalPlatformDirToBuild(type: Copy) {
        from globalPlatformDir
        into buildPlatformDir
    }
    tasks.copyGlobalPlatformDirToBuild.dependsOn(tasks.copyGlobalPlatformDirToProject)
}

// GIT maintenance tasks

// Provide session factory to jgit
SshSessionFactory.setInstance(new sx.jsch.ConfigSessionFactory())

/**
 * Removes GIT tags in root in local and remote repositories
 */
task gitRemoveRootTags {
    group = 'git'

    doLast {
        def git = Git.open(project.rootDir)

        def lc = git.tagList()
        def tags = lc.call()

        def toDelete = tags
                .findAll {
            def file = new File(it.name)
            def root = new File("refs/tags")
            (file.parentFile.equals(root))
        }

        toDelete.forEach {
            println("Removing ${it.name} ${it.leaf}")
        }

        def push = git.push()
                .setRefSpecs(
                toDelete.collect {
                    new RefSpec().setSource(null).setDestination(it.name)
                })
        push.call()

        def td = git.tagDelete()
        td.setTags(*toDelete.collect { it.name })
        td.call()

        git.close()
    }
}

/**
 * GIT subtrees
 */
def subtrees = [
        [
                name : 'CentralSchema',
                path : 'leoz-central-schema',
                repo : 'ssh://git@git.derkurier.de:13020/leoz/leoz-central-schema.git',
                ref  : 'master',
                group: 'git'
        ],
        [
                name: 'SxAndroid',
                path: 'libs/sx-android',
                repo: 'ssh://git@git.derkurier.de:13020/leoz/sx-android.git',
                ref : 'master'
        ],
        [
                name: 'SxAndroidHoneywell',
                path: 'libs/sx-android-honeywell',
                repo: 'ssh://git@git.derkurier.de:13020/leoz/sx-android-honeywell.git',
                ref : 'master'
        ],
        [
                name: 'SxCommon',
                path: 'libs/sx-common',
                repo: 'ssh://git@git.derkurier.de:13020/leoz/sx-common.git',
                ref : 'master'
        ],
        [
                name: 'SxDiscovery',
                path: 'libs/sx-discovery',
                repo: 'ssh://git@git.derkurier.de:13020/leoz/sx-discovery.git',
                ref : 'master'
        ],
        [
                name: 'SxFx',
                path: 'libs/sx-fx',
                repo: 'ssh://git@git.derkurier.de:13020/leoz/sx-fx.git',
                ref : 'master'
        ],
        [
                name: 'SxMq',
                path: 'libs/sx-mq',
                repo: 'ssh://git@git.derkurier.de:13020/leoz/sx-mq.git',
                ref : 'master'
        ],
        [
                name: 'SxPackager',
                path: 'libs/sx-packager',
                repo: 'ssh://git@git.derkurier.de:13020/leoz/sx-packager.git',
                ref : 'master'
        ],
        [
                name: 'SxPackagerGradle',
                path: 'libs/sx-packager-gradle',
                repo: 'ssh://git@git.derkurier.de:13020/leoz/sx-packager-gradle.git',
                ref : 'master'
        ],
        [
                name: 'SxRsync',
                path: 'libs/sx-rsync',
                repo: 'ssh://git@git.derkurier.de:13020/leoz/sx-rsync.git',
                ref : 'master'
        ],
        [
                name: 'SxSerialization',
                path: 'libs/sx-serialization',
                repo: 'ssh://git@git.derkurier.de:13020/leoz/sx-serialization.git',
                ref : 'master'
        ],
        [
                name: 'SxSsh',
                path: 'libs/sx-ssh',
                repo: 'ssh://git@git.derkurier.de:13020/leoz/sx-ssh.git',
                ref : 'master'
        ],
        [
                name: 'MaterialSheetFab',
                path: 'leoz-mobile/libs/material-sheet-fab',
                repo: 'ssh://git@github.com/masc3d/material-sheet-fab.git',
                ref : 'master'
        ]
]

/**
 * Push all subtrees at once
 */
task gitSubtreePushAll {
}

task gitSubtreePullAll {
}

task gitSubtreeSplitAll {
}

// Build tasks dynamically for each subtree
subtrees.each { subtree ->
    def taskNamePull = "gitSubtreePull${subtree['name']}"
    task "${taskNamePull}" {
        group = subtree['group']

        doLast {
            println "Pulling subtree ${subtree}"

            def sw = new Stopwatch().start()
            try {
                def result = ProcessExecutor.run([
                        'git', 'subtree', 'pull', '--squash', '-P', subtree['path'], subtree['repo'], subtree['ref']])

            } catch (ProcessRunException e) {
                throw new IllegalStateException(e.result.error)
            }
            println "Completed in ${sw}"
        }
    }
    tasks.gitSubtreePullAll.dependsOn "${taskNamePull}"

    def taskNamePush = "gitSubtreePush${subtree['name']}"
    task "${taskNamePush}" {
        group = subtree['group']

        doLast {
            println "Pushing subtree ${subtree}"

            def sw = new Stopwatch().start()
            try {
                def result = ProcessExecutor.run([
                        'git', 'subtree', 'push', '-P', subtree['path'], subtree['repo'], subtree['ref']])

            } catch (ProcessRunException e) {
                throw new IllegalStateException(e.result.error)
            }
            println "Completed in ${sw}"
        }
    }
    tasks.gitSubtreePushAll.dependsOn "${taskNamePush}"

    def taskNameSplit = "gitSubtreeSplit${subtree['name']}"
    task "${taskNameSplit}" {
        doLast {
            println "Splitting subtree ${subtree}"

            def branchName = "split/${subtree['path']}".toString()

            def sw = new Stopwatch().start()
            try {
                def result = ProcessExecutor.run([
                        'git', 'subtree', 'split', '--rejoin', '-P', subtree['path'], '-b', branchName, '--annotate', "[${subtree['path'].replace('/', '-')}] ".toString()
                ])
            } catch (ProcessRunException e) {
                throw new IllegalStateException(e.result.error)
            }

            try {
                def result = ProcessExecutor.run([
                        'git', 'branch', '-d', branchName
                ])
            } catch (ProcessRunException e) {
                throw new IllegalStateException(e.result.error)
            }
            println "Completed in ${sw}"
        }
    }
    tasks.gitSubtreeSplitAll.dependsOn "${taskNameSplit}"
}